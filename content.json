{"pages":[],"posts":[{"title":"Java内存模型","text":"as-if-serial属性 菩提本无树, 何处惹尘埃。 即时编译器(和处理器)需要保证程序能够遵守as-if-serial属性。通俗地说, 就是在单线程情况下, 要给程序一个顺序执行的假象。即经过重排序的执行结果要与顺序执行的结果一致。 另外, 若两个操作之间存在数据依赖, 那么及时编译器(和处理器)不能调整它们的顺序, 否则将会造成程序语义的改变。 happens-before 关系 问渠那得清如许? 唯有源头活水来。 描述两个操作的内存可见性的。如果操作X happens-before 操作Y, 那么X的结果对于Y可见(Y观测X的结果) Java内存模型定义的线程间happens-before关系 1。解锁操作 happens-before 对该所锁的加锁操作(时序)2。volatile字段的写操作 happens-before 对该volatile字段的读操作(时序)3。线程的启动(start) happens-before 线程的第一个操作4。线程的最后一个操作 happens-before 线程的终止事件(即其他线程通过Thread.isAlive() 或 Thread.join()判断该线程是否中止)5。线程对其他线程的中断操作 happens-before 被中断线程收到的中断事件(即被中断线程的InterruptedException异常, 或者第三个线程针对被中断线程的Thread.interrupted 或者 Thread.isinterrupted调用)6。构造器中的最后一个操作 happens-before 析构器的第一个操作 另外happens-before关系还具备传递性. Java内存模型的底层实现 Java内存模型是通过内存屏障(memory barrier)来禁止重排序的. 对于即使编译器来说, 它会针对每个happens-before 关系, 向正在编译的目标方法中插入相应的读读,读写,写读,写写内存屏障。 这些内存屏障会限制即时编译器的重排序操作。以volatile字段访问为例, 所插入的内存屏障将不允许volatile字段写操作之前的内存访问被重排序至其后; 也将不允许bolatile字段读操作之后的内存访问被重排序至之前。volatile字段的内存屏障是什么类型? 即时编译器会根据具体的底层体系架构, 将内存屏障替换成具体的CPU指令。以我接触最多的X86_64架构来说, 读读,读写以及写写内存屏障是空操作(no-op), 只有写读内存屏障会被替换成具体指令 这样理解重排序Java代码本应该按源码顺序执行, 但是编译器对部分代码会进行优化, 提高执行效率(cpu 或 内存) 然而, 禁止重排序是处于某种目的(业务逻辑/happens-before)开发人员对编译器的代码重排序进行一定的限制。 对于即时编译器来说, 它会针对happens-before关系, 向正在编译的目标方法中插入相应的内存屏障(读读,读写,写读,写写) volatilevolatile字段写操作之后的写读内存屏障需要用具体指令来替代.(HotSpot 所选取的具体指令是 lock add DWORD PTR[rsp],0x0, 而非mfence[3].)在具体指令的效果, 可以简单理解为强制刷新处理器的写缓存。写缓存是处理器用来加速内存存储效率的一项技术。在碰到内存写操作时, 处理器并不会等待该指令结束, 而是直接开始下一指令, 并且依赖于写缓存将更改的数据同步至主内存之中。强制刷新写缓存,将使得当前线程写入volatile字段的值(以及写缓存中已有的其他内存修改), 同步至主内存之中。强制刷新写缓存, 将是得当前现成写入volatile字段的值(以及写缓存中已有的其他内存修改), 同步至主内存之中。由于内存写操作(强制刷新缓存)同时会无效化其他处理器所持有的指向同一内存地址的缓存行, 因此可以认为其他处理器能够立即见到该volatile字段的最新值。 锁前面提到锁具备happens-before关系。具体来说, 解锁操作happens-before之后对同一把锁的枷锁操作。实际上, 在解锁时, Java虚拟机同样需要强制刷新缓存, 使得当前线程所修改的内存对其他线程可见。锁操作具备happens-before关系。具体来说, 解锁操作happens-before之后对同一把锁。也就是说, 如果编译器能够(通过逃逸分析)证明某把锁仅被同一线程持有, 那么它可以移除相应的加锁解锁操作。 finalfinal实例字段涉及新建对象的发布问题。当一个对象包含final实例字段时, 我们希望其他线程智能看到已初始化的实例字段。 因此, 即时编译器会在final字段的写操作后插入一个写写屏障, 以防某些优化将新建对象的发布(即将实例对象写入一个共享引用中) 重排序至final字段的写操作之前。在X86_64平台上, 写写屏障是空操作 新建对象的安全发布问题(safe publication)问题不仅仅包括final实例字段的可见性, 还包括其他实例字段的可见性。 https://vlkan.com/blog/post/2014/02/14/java-safe-publication/","link":"/2020/03/10/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"},{"title":"Java对象的内存布局","text":"java对象的额外内存开销(对象头)运行数据 (8字节)包括 哈希码 GC信息 所信息 对象类型指针 (8字节) 指向对象对应的类 压缩指针 通过 jvm命令选项开启 -XX:+UseCompressedOops这里针对对象类型指针, 实际上对所有引用指针起作用 对于64位java虚拟机 64位 -&gt; 32位因此java对象的额外内存开销为12字节 内存对齐 通过jvm选项 -XX:ObjectAlignmentlnBytes开启进一步提升了寻址范围. 同时也有可能增加对象间内存填充, 倒置压缩指针没有到达原本节省空间的效果. 对象内存对齐对象内字段内存对齐java虚拟机要求long字段,double字段以及非压缩指针状态下的引用字段地址为8的倍数 do for what? 让字段支出现在同一CPU的缓存行种. 如果字段不是对齐的, 那么可能出现跨缓存行的字段. 该对象的读取可能需要替换两个缓存行, 该字段的存储也会同时污染来那个缓存行. 对程序的执行效率不利. 字段重排列 通过jvm选项 -XX:FieldsAllocationStyle(默认为1)开启java虚拟机重新分配源代码中声明的字段先后顺序, 以达到内存对齐的目的. 规则 如果字段占据C个字节, 那么该字段的偏移量需要对齐至NC. 这里偏移量指的是字段起始地址与对象的起始地址的差值 例如: Long类型有一个long字段, 在使用了压缩指针的64位虚拟机中 1long字段的地址 = n*16 + 对象起始地址 (n=1) 子类所继承的偏移量, 需要与父类的对应字段一致在具体实现中，Java 虚拟机还会对齐子类字段的起始位置。对于使用了压缩指针的 64 位虚拟机，子类第一个字段需要对齐至 4N；而对于关闭了压缩指针的 64 位虚拟机，子类第一个字段则需要对齐至 8N。 class A { long l; int i；} class B extends A { long l; int i;}我在文中贴了一段代码，里边定义了两个类 A 和 B，其中 B 继承 A。A 和 B 各自定义了一个 long 类型的实例字段和一个 int 类型的实例字段。下面我分别打印了 B 类在启用压缩指针和未启用压缩指针时，各个字段的偏移量。 启用压缩指针时，B 类的字段分布B object internals: 1OFFSET SIZE TYPE DESCRIPTION2 0 4 (object header)3 4 4 (object header)4 8 4 (object header)5 12 4 int A.i 06 16 8 long A.l 07 24 8 long B.l 08 32 4 int B.i 09 36 4 (loss due to the next object alignment) 当启用压缩指针时，可以看到 Java 虚拟机将 A 类的 int 字段放置于 long 字段之前，以填充因为 long 字段对齐造成的 4 字节缺口。由于对象整体大小需要对齐至 8N，因此对象的最后会有 4 字节的空白填充。 关闭压缩指针时，B 类的字段分布B object internals: 1OFFSET SIZE TYPE DESCRIPTION2 0 4 (object header)3 4 4 (object header)4 8 4 (object header)5 12 4 (object header)6 16 8 long A.l7 24 4 int A.i8 28 4 (alignment/padding gap) 9 32 8 long B.l10 40 4 int B.i11 44 4 (loss due to the next object alignment) 当关闭压缩指针时，B 类字段的起始位置需对齐至 8N。这么一来，B 类字段的前后各有 4 字节的空白。那么我们可不可以将 B 类的 int 字段移至前面的空白中，从而节省这 8 字节呢？ 是可以节省的, 这可能是一个历史遗留问题 虚共享问题 两个线程分别访问同一个对象中不同的volatile字段, 逻辑上它们并没有共享内容, 因此不需要同步.然而, 如果这两个字段恰好在同一个缓存行中, 那么对这些字段的写操作会导致缓存行的写会, 造成了实质上的共享. java虚拟机会让不同的@Contended字段之间处于独立的缓存行, 因此造成大量空间浪费, 具体的分布算法属于实现细节. 通过jvm选项-XX:-RestrictContended查阅Contended字段的内存布局(if java version &gt; 9 编译时需要–add-exports java.base/jdk.internal.vm.annotation=ALL-UNNAME)","link":"/2020/02/21/Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"},{"title":"Java反射API的用法","text":"获取Class对象 Class.forName获取Class对象 getClass()方法 直接使用类名+”.class”. 对于基本数据类型, 它们的包装类型拥有一个名为”TYPE”的final静态字段, 指向该基本数据类型对应的Class对象 integer.TYPE 指向 int.class对于数组类型 可以使用类名+ “[].class”来访问, 如int[].class 拿到Class对象后 使用newInstance()生成一个实例(需要一个无参构造器) 使用isInstance(Object)来判断一个对象是否是该类的实例, 语法上等同于instance of 关键字(JIT 优化时会有差别?) 使用Array.newInstance(Class,int)来构造该类型的数组 使用getFIelds()/getConstructors()/getMethods() 来访问该类型的成员. 带Declared的方法不会返回父类成员,但是会返回私有成员 拿到类成员后 使用Constructor/Field/Method.setAccessible(true)来绕开Java语言的访问限制(如private). 使用Constructor.newInstance(Object[])来生成该类的实例 使用Field.get/set(Objcet)访问字段 使用Method.invoke(Object, Object[])来调用方法 反射调用栈 默认情况下反射调用为委派实现, 委派给本地实现来进行方法实现来进行方法调用. 在达到阈值超过15次(第15次)委派实现会将委派对象DelegatingMethodAccessorImpl切换至动态实现(自动生成字节码(耗时)), 它将直接使用invoke指令来调用目标方法 反射性能开销原因 不定长参数导致的Object数组 基本数据类型的自己装箱拆箱 方法内联 (将本方法内调用的方法与自己一起编译)","link":"/2020/02/22/Java%E5%8F%8D%E5%B0%84API%E7%9A%84%E7%94%A8%E6%B3%95/"},{"title":"Java工具集LTS","text":"使用javap来查看字节码 默认情况下打印所有非私有方法和字段 -p选项 还会打印私有方法和字段 -v选项 尽可能打印所有信息(这里指) -c选项 只查看方法对应字节码 JOL工具 1curl -L -O http://central.maven.org/maven2/org/openjdk/jol/jol-cli/0.9/jol-cli-0.9-full.jar2java -cp jol-cli-0.9-full.jar org.openjdk.jol.Main internals java.lang.String jol地址已失效 -&gt; 新地址 jvm调试命令-XX:+ -XX:+UseCompressedOops 开启对象压缩指针 64位 -&gt; 32 位 这里使用内存对齐(8位)使后三位为0, 也可以用这3位来记录一些额外信息 扩大寻址范围32位-&gt;35位. -XX:ObjectAlignmentLnBytes 字节对齐 java虚拟机堆中的起始地址需要对齐至8的倍数 对象之间有内存对齐, 对象之间的字段也需要内存对齐(否则, 字段的读取需要替换两个缓存行, 存储会同时污染来那个缓存行, 影响执行效率) jps 打印所有正在运行的进程的相关信息。 帮助文档 -m 将打印传递给Java虚拟机的参数 -l 将打印模块名以及包名 -v 将打印传递给 Java 虚拟机的参数（如-XX:+UnlockExperimentalVMOptions -XX:+UseZGC） jstat 打印目标Java进程的性能数据。 帮助文档$ jstat -options-class-compiler-gc-gccapacity-gccause-gcmetacapacity-gcnew-gcnewcapacity-gcold-gcoldcapacity-gcutil-printcompilation 例： 1jstat -gc -t 22126 1s 4 jmap 分析虚拟机堆中的对象 帮助文档-clstats-finalizerinfo-histo-dump 例： 1jmap -histo 22574 注意 以及jinfo、jstack和jcmd依赖于Java虚拟机的Attach API，因此只能监控本地Java进程一旦开启Java虚拟机参数DisableAttachMechanism（-XX:+DisableAttachMechanism)，基于Attach API的命令将无法执行。 远程跑java程序是否可以使用这些工具？ jinfo jinfo命令可用来查看目标Java进程的参数，如传递给Java虚拟机的-X(即输出中的VM Flags），以及可在Java层面通过System.getProperty获取的-D参数（即输出中的System Properties）。可以改动manageable的参数 帮助文档例: 1jinfo 73269 jstack jstack命令可以用来打印目标Java进程中各个线程的栈轨迹，以及这些线程所持有的锁。 帮助文档jstack的其中一个应用场景便是死锁检测。jstack不仅会打印线程的栈轨迹、线程状态（BLOCKED）、持有的锁（locked …）以及正在请求的锁（waiting to lock …），而且还会分析出具体的死锁。 例： 1jstack 73269 jcmd 可以使用jcmd命令，来代替除了jstat之外的所有命令。 帮助文档","link":"/2020/02/21/Java%E5%B7%A5%E5%85%B7%E9%9B%86LTS/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/03/11/hello-world/"},{"title":"MacOs catalina 配置zsh别名和主题","text":"zsh主题1autoload -Uz promptinit 2promptinit 3prompt -l //列出主题4prompt walters 在命令行中用过后添加一下内容(当中的fade是一个主题)到 ~/.zshrc 之后source一下,就配置到zsh了 1autoload -Uz promptinit2promptinit3prompt fade &quot;red&quot; zsh配置别名配置文件 ~/.zshrc配置方式例如: 1alias zshconfig=&quot;vim ~/.zshrc&quot;2alias -s py=vi #在命令行输入python文件,会用vim打开 再source一下","link":"/2019/12/01/MacOs-catalina-%E9%85%8D%E7%BD%AEzsh%E5%88%AB%E5%90%8D%E5%92%8C%E4%B8%BB%E9%A2%98/"},{"title":"配置OpenCV","text":"Cmake编译Opencv 国庆期间配置了下开发环境,记录一下遇到的坑 一、安装MinGW-64 用于编译opencv库 下载MinGW-64 直接安装即可,注意选择x86_64架构,我选择的是7.3.0版本 另外添加环境变量 可以用 gcc -v 和g++ -v检查 二、 安装cmake下载cmake 安装 配置环境变量 可以用cmake –version检查 三、 安装clion JetBrains家的一款c(c++)IDE 默认安装即可 激活码1812LFWMRSH-eyJsaWNlbnNlSWQiOiI4MTJMRldNUlNIIiwibGljZW5zZWVOYW1lIjoi5q2j54mIIOaOiOadgyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjAxOS0wNC0yMSIsInBhaWRVcFRvIjoiMjAyMC0wNC0yMCJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjAxOS0wNC0yMSIsInBhaWRVcFRvIjoiMjAyMC0wNC0yMCJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMDQtMjEiLCJwYWlkVXBUbyI6IjIwMjAtMDQtMjAifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMDQtMjEiLCJwYWlkVXBUbyI6IjIwMjAtMDQtMjAifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMDQtMjEiLCJwYWlkVXBUbyI6IjIwMjAtMDQtMjAifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMDQtMjEiLCJwYWlkVXBUbyI6IjIwMjAtMDQtMjAifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwMTktMDQtMjEiLCJwYWlkVXBUbyI6IjIwMjAtMDQtMjAifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA0LTIxIiwicGFpZFVwVG8iOiIyMDIwLTA0LTIwIn0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA0LTIxIiwicGFpZFVwVG8iOiIyMDIwLTA0LTIwIn0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA0LTIxIiwicGFpZFVwVG8iOiIyMDIwLTA0LTIwIn0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA0LTIxIiwicGFpZFVwVG8iOiIyMDIwLTA0LTIwIn0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA0LTIxIiwicGFpZFVwVG8iOiIyMDIwLTA0LTIwIn0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA0LTIxIiwicGFpZFVwVG8iOiIyMDIwLTA0LTIwIn0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA0LTIxIiwicGFpZFVwVG8iOiIyMDIwLTA0LTIwIn0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDE5LTA0LTIxIiwicGFpZFVwVG8iOiIyMDIwLTA0LTIwIn0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjAxOS0wNC0yMSIsInBhaWRVcFRvIjoiMjAyMC0wNC0yMCJ9XSwiaGFzaCI6IjEyNzk2ODc3LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-ti4tUsQISyJF/zfWxSHCr+IcYrX2w24JO5bUZCPIGKSi+IrgQ0RT2uum9n96o+Eob9Z1iQ9nUZ6FJdpEW5g0Exe6sw8fLrWMoLFhtCIvVgQxEEt+M7Z2xD0esmjP1kPKXZyc/i+NCxA2EO2Sec9uifqklBGP1L3xoENAw2QsIWBfttIe6EPWhbS8TIMMr2vF/S3HrN8To5Hj5lwD/t1GHgFK1uWrhsuifAiKcVzqogybzGiR1h2+yNYTMbKxP7uPCcdYMsIyrBNVRGA3IuEJgyGQTQlFbnVQoVUTGPW2tQxprmC464wMjKi40JHh27WzjOHPwgzxDaigwn4Z0EbSpA==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow== 四、编译opencv 这里是用的是opencv3.2 下载opencv 选择对应平台下载并解压 打开cmake where is the source code选择source文件夹 where is the binaries 选择 新建的mingw64-build文件夹 注意上面两个路径不能含有中文目录结构,否则后面会报错 configure 等待配置 configure 等待配置 Gernerate 生成 cmd进入mingw64-build路径 输入 mingw32-make -j8 输入 mingw32-make install 将mingw64下的bin目录配置到环境变量","link":"/2019/11/28/%E9%85%8D%E7%BD%AEOpenCV/"},{"title":"java入门学习","text":"Java (c++-)学习笔记 day1 4/14 2019 Java 核心优势:跨平台/可移植性Java 各个版本javaEE(Java Enterprise Edition):企业版:定位在服务器上的应用&lt;br&gt; JavaME:微型版----会被安卓取代&lt;br&gt; JavaSE==:(Java Sandard Edition) :标准版:定位在个人计算机的应用&lt;br&gt;Java 特点简单,分布式,多线程,高性能,健壮 JVM/JRE/JDKJVM(Java Virtual Machine)虚拟机执行字节码 JRE(Java Runtime Environment) :包含jvm,库函数,必须文件 JDK(Java Development Kit):包含Jre day2 4/15 2019 抽象类和抽象方法 1.有抽象方法的类只能是抽象类 2.抽象类不能实例化(不能用new实例化抽象类),可以用子类实例 3.抽象类可以包含属性、方法、构造方法,但是构造方法不能用来new实例,只能用来被子类调用 4.抽象类只能被继承 5.抽象方法必须被子类实现接口和多继承接口interface(接口就是规范) 方法全部为抽象方法 变量全为常量 支持多继承 不能创建实例 ,但是可以用于引用变量类型 jdk1.8后包含普通的静态方法实现implement(类似extends)内部类非静态内部类 day3 4/16 2019 容器类 collection 容器(集合) List 有顺序,可重复 ArrayList LinkedList Set 无顺序,不可重复 HashSet Map 键值对 HashMap TreeMap collection 方法 1add()2toArrary()3isempty()4remove()5contains()6size()7clear()8-----------------------------------9addAll()10containsAll()11removeAll()12retainAll() set方法和collection基本相同 set 不允许`e1.equals(e2)==true`的对象放入List 有序:List中每个元素都有索引标记 可重复:允许加入重复的元素 ArrayList(数组)1indexOf() 返回第一次出现的对象的索引值 2lastIndex() 返回最后一次出现的对象的索引值3copyOf(elementData , int)4copy5add(E)6add(int,E)7remove(int)8System.arraycopy(elementData ,index+1,elementData,index)9clear() LinkedList(链表)Vector(线程安全的数组)泛型 Java中泛型的引入是通过泛型擦除机制来实现的泛型只在编译中被编译器javac识别&amp;使用，用来确保数据的安全性&amp;免去强制类型转换的麻烦。 可以用继承的方式限制参数类型 extends Number类可以起到c#中 where T:struct的作用 day4 4/27 2019 Java异常类型机制类结构 Thrwoable Error Exception CheckedException RuntimeException uncheckExceptionRutimeException 运行时异常由JRE抛出通常需要程序员去修改 checkedException 由编译器处理，在编译时会及时报错 处理方法 try catch finally 语法格式 向外抛出，一直到抛到JRE day5 4/29 2019 注解注释是给人程序员看的，注解是给给程序看的 @Override：重写 @Deprecated：过时 @Suppress warning：压制警告元注解 注释注解用的@Target修饰注解作用范围1ElemetnType.Type2Type-&gt;3PACKAGE-包4TYPE-类、接口、枚举值、Annotation类型5 类型成员：6 1.CONSTRUCTOR-构造器7 2.FELD-描述域/字段8 3.METHOD-描述方法9LOCAL_VARIABLE-描述局部变量10PARAMETER-描述参数 @Retention-保留表示需要在什么级别保存该注释信息（生命周期）取值 RetentionPolicy | 作用/保留域 -|–SOURCE | 在源文件中有效/源文件保留CLASS | 在class文件中有效/class保留RUNTIME | 在运行时有效/运行时保留可以被反射机制读数 @Documente@Inheritedday6 5/1 2019 反射机制 在运行时加载、探知、使用、编译期间完全未知的类。程序运行时，可以动态加载一个只有名称的类，对于任意一个已加载的类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个属性和方法；加载完类后，在堆内存中，就产生了一个Class类型的对象(一个类只有一个Class对象)，这个对象包含了完整的累的结构信息。它的作用类似一个图纸的作用，这个对象就像是一面镜子，透过这个镜子看到类的结构，我们称之为反射。 反射的根源是Class类 反射可以用来干什么？ 动态加载类、动态获取类的信息（属性、方法、构造器） 动态构造对象 动态调用类和对象的任意方法、构造器 动态调用和处理属性 获取泛型信息 处理注解 java.lang.Class 一个类被加载后，JVM会创建一个对应该类的Class对象,类的整个结构信息会被放到对应的Class对象中 JDK简介Instance of the class (Class) represent classes and interfaces in a running Java application.Anenum type is a kind of class and an annotation type is a kind of interface.Every array also belongsto a class that is reflected as aobject that is shared by all arrays with the same element type and number of dimensions.The primitive Java types,and the keyword(void) are also represented as objects.译:Class类的实例代表了正在运行的java类和对象。一个枚举class是一个类一个注解class是一个接口。每个数组从属于一个类，且相同数据类型同时维度相同的类从属于同一个类(同样的hashcode)。基本数据类型同和void关键字同样被视为一个类 Class类对象的获取方式1Class clazz = Class.forName(&quot;path&quot;) -最常使用2Class clazz = path.getclass()3Class clazz = class.class day7 5/2 2019 ### 反射操作类的名称、属性、方法、构造器 - 反射创建对象 1Class clazz = Class.forName(path);2User u1 = (User)clazz.newInstance();3or加上泛型 4Class&lt;User&gt; clazz = (Class&lt;User&gt;) Class.forName(path)5User u1 = clazz.newInstance(); 反射获取类的名称1try{2 Class clazz = Class.forName(&quot;com.sdz.&quot;)3 String name = clazz.getName()；4 String simplename = clazz.getSimpleName();5}catch (Exception e){6 printStackTrace7} 反射获取类的属性1Field f1 = clazz.getDeclaredField(String)2Field fields = clazz.getDeclareField()3- 反射获取类的注解 反射操作类的属性1User u = clazz.newInstance();2f1.setAccessible(true);//跳过安全检查，提高反射性能，大约是原来的4倍3f1.set(u,&quot;孙东哲&quot;);//通过反射写属性4System.out.printle(f1.get());//通过反射读属性 反射获取类的方法1Method m1 = clazz.getDeclaredMethod(&quot;getUname&quot;);2Method[] methods = clazz.getDeclaredMethods(); 反射调用普通方法1User u = clazz.newInstance();2m1.invoke(u,&quot;孙东哲&quot;); 反射获取类的构造器1Constructor c1 = clazz.getDeclaredConstructor(int.class,int.class,String.class);2Constructor[] constructors = clazz.getDeclaredConstructors(); 反射调用构造方法1User u = clazz.newInstance();//无参构造器2c1.newInstance(1001,18,孙东哲); 反射的性能 反射的速度很慢，大约是普通方法调用的30倍但是如果跳过反射的安全检查，反射的速度可以增加4倍 反射操作泛型Java中泛型是给编译器看的，即生命周期仅限于编译期间所以 ，Java增加了ParameterizedType，GenericArrayType,TypeVariable,WildcardType几种类型来代表不能被归一到Class类中的类型但是又和原始类型齐名的类型 ParameterizedType(参数化类型)例如：Collection GenericArrayType表示一种元素类型是参数化类型或者类型变量的数组类型 TypeVariable是各种类型变量的公共父接口 WildcardType 代表一种通配符类型表达式，比如？，？extends Number，？super Integer 反射操作注解1try 2{3 //获取Class对象4 Class clazz = Class.forName(&quot;com.bjsxt.test.annotation.SxtStudent&quot;);5 //获得类的所有有效注解6 Annotation[] annotations=clazz.getAnnotations(); for (Annotation a : annotations) {7 System.out.println(a); }8 //获得类的指定的注解9 SxtTable st = (SxtTable) clazz.getAnnotation(SxtTable.class); System.out.println(st.value());10 //获得类的属性的注解11 Field f = clazz.getDeclaredField(&quot;studentName&quot;);12 SxtField sxtField = f.getAnnotation(SxtField.class); System.out.println(sxtField.columnName()+&quot;--&quot;+sxtField.type()+&quot;--&quot;+sxtField.length());13 //根据获得的表名、字段的信息，拼出DDL语句，然后，使用JDBC执行这个SQL，在数 据库中生成相关的表14} catch (Exception e) {15e.printStackTrace();16} IO流文件创建 mkdir() mkdir() List() day3 5/14 2019 final和conset的区别final 修饰的变量定义时就需要初始化但是他的值是在运行时确定例如 1int final a = fn(); const 修饰的变量在编译时就被确定了 day1 5/25 2019 Java的回调函数 回调函数是由指针实现的，即在特定的事件或条件发生时由另外的一方调用的，作为该事件或条件的响应 而java中删除了指针的概念，但是可以通过接口和内部类来实现回调的功能： 步骤 1 定义接口Callback，包含回调方法callback() 2 在一个类Caller中声明一个Callback接口对象mCallback 3 在程序中赋予Caller对象的接口成员(mCallback)一个内部类对象例如1new Callback(){2 callback(){3 //具体实现4 }5} 这样就可以在需要的时候，用Caller对象的mCallback接口成员，调用callback()方法，完成回调。 总结 1 声明回调函数的统一接口(实现可以不同)interface A，包含func() 2 在调用类caller中将该接口设置为私有成员private A xxx; 3 在caller内提供一个public的方法，可以将外部“改接口的实现类的引用”通过形参传给XXX; 4 caller的某个方法call()中会用到xxx.fun()方法； 5 在caller的实例中，将实现了A接口的对象的引用传给caller，后调用caller()方法 day10 6/7 2019 单例模式 1.懒汉式 2.恶汉式 3.双重锁模式 4.静态内部类实现 5.枚举实现 uml绘制 rational rose metamill 工厂模式原则 1.OCP开闭原则 2.DIP依赖倒置原则 3.LoD迪米特原则 简单工厂模式方法工厂模式抽象工厂模式原型模式适配器模式 day11 6/16 2019 桥接模式针对不稳定的情况(解决多继承，多个维度) 组合模式 关键 对整个树结构里的部分对象和整体对象都是一个统一的处理模式. 在其中有天然的递归 装饰模式针对稳定的，增加新的功能 外观模式封装 享元模式 1内部状态 可共享 2外部状态相似或相同对象——》 优点 1 减少对象数量，节省内存2 外部状态相对独立 缺点 1 模式较复杂2 节省运行时间 责任链模式（chain of responsibility)代替大量的if else 语句 处理同一类请求的对象 迭代器模式 (iterator)/游标模式cursor提供一种可以遍历聚合对象的方式通常以内部类的形式出现在聚合对象，便于操作外部对象JDK中的set/List等会使用 中介者模式 (Mediator)应对复杂结构 day12 8/6 2019 枚举类枚举是一个特殊的类,域成员均为常量命名时在结尾加上Enum 如:ProcessStatusEnum变量全部用大写并用下划线隔开","link":"/2019/11/28/java%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"},{"title":"mysql 登录失败","text":"mysql -u root -p报错 ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/tmp/mysql.sock’ (2) 这是因为mysql服务没有启动启动命令如下 mysql.server startorbrew services start mysql","link":"/2020/01/29/mysql-%E7%99%BB%E5%BD%95%E5%A4%B1%E8%B4%A5/"}],"tags":[{"name":"java","slug":"java","link":"/tags/java/"},{"name":"OpenCV","slug":"OpenCV","link":"/tags/OpenCV/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"}],"categories":[]}